---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lele.
--- DateTime: 09/09/23 11:08
---

---@class ActivityCalendar

local ActivityCalendar = {}

local dataValidator = require("lib/DataValidator")
local errHandler = require("lib/ErrHandler")
local month = {
    Jan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6,
    Jul = 7, Aug = 8, Sep = 9, Oct = 10, Nov = 11, Dec = 12
}

---@type int
local SECOND_IN_DAY = 86400

---@type double
local expectedDateInSecond

--- **Get Time In Millis**
---@return double
--- - PZCalendar : zombie.util.PZCalendar
local function getTimeInMillis()
    return getGameTime():getCalender():getTimeInMillis()
end

--- **???? DEPRECATED - Work ????**
--- **Set Time In Millis**
---@param millisSeconds double
---@return void
--- - PZCalendar : zombie.util.PZCalendar
---@deprecated
local function setTimeInMillis(millisSeconds)
    if not dataValidator.isDouble(millisSeconds) then
        errHandler.errMsg("setTimeInMillis(millisSeconds)",
                errHandler.err.IS_NOT_DOUBLE_FLOAT)
        return nil
    end

    getGameTime():getCalender():setTimeInMillis(millisSeconds)
end

--- **Get Time**
---@return string
--- - The date retrieved from API is 24 hours behind the digital clock in game
--- - Format date: Fri Jul 09 09:43:41 CEST 1993
function ActivityCalendar.getTime()
    return tostring( getGameTime():getCalender():getTime() )
end

--- **From seconds to date**
---@param timestamp double
---@return string
--- - "Fri Jul 09 09:43:41 CEST 1993"
function ActivityCalendar.fromSecondToDate(timestamp)
    if not dataValidator.isDouble(timestamp) then
        errHandler.errMsg("fromSecondToDate(timestamp)",
                errHandler.err.IS_NOT_DOUBLE_FLOAT)
        return nil
    end

    local formattedDate = os.date("%a %b %d %H:%M:%S %Z %Y", timestamp)
    return formattedDate
end

---  **From millis to date**
---@param timestamp double
---@return string
--- - "Fri Jul 09 09:43:41 CEST 1993"
function ActivityCalendar.fromMillisToDate(timestamp)
    if not dataValidator.isDouble(timestamp) then
        errHandler.errMsg("fromMillisToDate(timestamp)",
                errHandler.err.IS_NOT_DOUBLE_FLOAT)
        return nil
    end

    local millisToSeconds = timestamp * 1000
    return ActivityCalendar.fromSecondToDate(millisToSeconds)
end

--- **Extract Date**
---@param date string
---@return int
--- - "Fri Jul 09 09:43:41 CEST 1993"
function ActivityCalendar.extractDate(date)
    --- **Check if date is string**
    if not dataValidator.isString(date) then
        errHandler.errMsg("extractDate(date)",
                errHandler.err.IS_NOT_STRING)
        return nil
    end

    ---@type table
    local dateParts = {}

    --- **Extract date**
    for datePart in date:gmatch("%S+") do
        table.insert(dateParts, datePart)
    end

    --- **Extract time**
    for hour, minute, second in date:gmatch("(%d+):(%d+):(%d+)") do
        dateParts[7] = hour
        dateParts[8] = minute
        dateParts[9] = second
    end

    --@type table
    --- - "Fri Jul 09 09:43:41 CEST 1993"
    local datePartsConverted = {
        ---@type string
        day = dateParts[1],
        ---@type number
        dayOfWeek = tonumber(dateParts[3]),
        ---@type string
        month = dateParts[2],
        ---@type number
        monthOfYear = month[dateParts[2]],
        ---@type string
        cest = dateParts[5],
        ---@type number
        year = tonumber(dateParts[6]),
        ---@type number
        hour = tonumber(dateParts[7]),
        ---@type number
        min = tonumber(dateParts[8]),
        ---@type number
        sec = tonumber(dateParts[9]),
    }

    --@type table
    local dateConverted = {
        ---@type number
        year = datePartsConverted.year,
        ---@type number
        month = datePartsConverted.monthOfYear,
        ---@type number
        day = datePartsConverted.dayOfWeek,
        ---@type number
        hour = datePartsConverted.hour,
        ---@type number
        min = datePartsConverted.min,
        ---@type number
        sec = datePartsConverted.sec,
    }

    return os.time(dateConverted)
end

--- **Get Seconds From Days**
---@param days int
---@return double seconds
local function getSecondsFromDays(days)
    if not dataValidator.isInt(days) then
        errHandler.errMsg("getSecondsFromDays(days)",
                errHandler.err.IS_NOT_INT)
        return nil
    end

    return days * SECOND_IN_DAY
end

--- **Get Days From Seconds**
---@param seconds double
---@return int days
local function getDaysFromSeconds(seconds)
    if not dataValidator.isDouble(seconds) then
        errHandler.errMsg("getDaysFromSeconds(seconds)",
                errHandler.err.IS_NOT_DOUBLE_FLOAT)
        return nil
    end

    return seconds / SECOND_IN_DAY
end

--- **Get Star Time**
--- - The date retrieved from API is 24 hours behind the digital clock in game, I added 24 hours
--- - Format date: Fri Jul 09 09:43:41 CEST 1993
---@return double seconds
local function getStarTime()
    ---@type string
    local date = ActivityCalendar.getTime()

    ---@type int
    --- **I added 24 hours**
    local dataAdjustment = ActivityCalendar.extractDate(date) + (SECOND_IN_DAY)
    return dataAdjustment
end

--- **Set Waiting Days**
---@param waitingDays int
---@return void
function ActivityCalendar.setWaitingOfDays(waitingDays)
    if not dataValidator.isNumber(waitingDays) then
        errHandler.errMsg("setWaitingOfDays(waitingDays)",
                errHandler.err.IS_NOT_NUMBER)
        return nil
    end

    expectedDateInSecond = getStarTime() + getSecondsFromDays(waitingDays)
end

--- **Set Expected Date In Seconds**
---@param expectedDate double
---@return void
function ActivityCalendar.setExpectedDateInSecond(expectedDate)
    if not dataValidator.isDouble(expectedDate) then
        errHandler.errMsg("setExpectedDateInSecond(expectedDate)",
                errHandler.err.IS_NOT_DOUBLE_FLOAT)
        return nil
    end

    expectedDateInSecond = expectedDate
end

--- **Get Expected Date In Seconds**
---@return double expectedDate
function ActivityCalendar.getExpectedDateInSecond()
    return expectedDateInSecond
end

--- **Is Expected Date**
---@return boolean
function ActivityCalendar.isExpectedDate()
    --- **Check if expectedDateInSecond is nil then setWaitingOfDays**
    if not expectedDateInSecond then
        ActivityCalendar.setWaitingOfDays(1)
    end

    --- **Check if the date is correct**
    if  getStarTime() >= ActivityCalendar.getExpectedDateInSecond() then
        return true
    end

    return false
end

return ActivityCalendar